// Generated by CoffeeScript 1.6.2
var argv, connect, counter, dgram, error_handler, fs, gauge, getStore, http, http_handlers, initStores, lss, shutdownStores, startHTTP, startUDP, stores, udp_handlers, url;

fs = require("fs");

url = require("url");

http = require("http");

connect = require("connect");

dgram = require("dgram");

argv = require('optimist').argv;

lss = require("./lss.js");

stores = {};

error_handler = function(req, res) {
  res.writeHead(404, {
    'Content-Type': 'text/plain'
  });
  return res.end("not found");
};

http_handlers = {
  "/dump_stores": function(req, res) {
    res.writeHead(200, {
      'Content-Type': 'application/json'
    });
    return res.end(JSON.stringify(stores));
  }
};

udp_handlers = {
  "gauge": function(args) {
    var gamma0, id, key, reset, timestamp, value;

    key = args[1];
    id = args[2];
    value = parseFloat(args[3]);
    gamma0 = parseFloat(args[4]) || 1.0;
    timestamp = parseFloat(args[5]) || new Date().getTime() / 1000;
    reset = Boolean(parseInt(args[6])) || false;
    if (key && value !== NaN) {
      return gauge(key, id, value, gamma0, timestamp, reset);
    }
  },
  "counter": function(args) {
    var gamma0, id, key, reset, timestamp;

    key = args[1];
    id = args[2];
    gamma0 = parseFloat(args[3]) || 1.0;
    timestamp = parseFloat(args[4]) || new Date().getTime() / 1000;
    reset = Boolean(parseInt(args[5])) || false;
    if (key) {
      return counter(key, id, gamma0, timestamp, reset);
    }
  }
};

shutdownStores = function() {
  var stores_file;

  stores_file = argv['stores'];
  if (!stores_file) {
    return;
  }
  return fs.writeFile(stores_file, JSON.stringify(stores), function(err) {
    if (err) {
      console.log("Error: " + err);
    } else {
      console.log("Stores saved to " + stores_file);
    }
    return process.exit();
  });
};

process.on('SIGINT', shutdownStores);

process.on('SIGTERM', shutdownStores);

initStores = function(filename) {
  if (!filename) {
    return;
  }
  return fs.readFile(filename, 'utf8', function(err, data) {
    var key, store, value;

    if (err) {
      console.log('Error: ' + err);
      return;
    }
    data = JSON.parse(data);
    for (key in data) {
      value = data[key];
      store = getStore(key);
      store.load(value);
    }
    return console.log("Stores loaded from " + filename);
  });
};

startUDP = function(udp_port) {
  var socket;

  socket = dgram.createSocket("udp4");
  socket.on("message", function(msg, rinfo) {
    var chunks, handler, message, metric_type, row, rows, _i, _len, _results;

    message = msg.toString();
    rows = message.split("\n");
    _results = [];
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      chunks = row.split(" ");
      metric_type = chunks[0];
      handler = udp_handlers[metric_type];
      if (handler) {
        _results.push(handler(chunks));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });
  socket.bind(udp_port);
  return console.log("UDP server running at 0.0.0.0:" + udp_port);
};

startHTTP = function(http_port) {
  connect().use(connect.logger('dev')).use(connect["static"]("" + __dirname + "/public")).use(connect["static"]("" + __dirname + "/components")).use(function(req, res) {
    var handler, url_data;

    url_data = url.parse(req.url);
    handler = http_handlers[url_data.pathname];
    if (!handler) {
      return error_handler(req, res);
    } else {
      return handler(req, res);
    }
  }).listen(1234);
  return console.log("HTTP server running at http://0.0.0.0:" + http_port + "/");
};

gauge = function(key, id, value, gamma0, timestamp, reset) {
  var dt, gamma, new_value, prev_timestamp, prev_value, store, _ref;

  key = key.toString();
  id = id.toString();
  store = getStore(key);
  _ref = store.get(id), prev_value = _ref[0], prev_timestamp = _ref[1];
  if (reset || prev_value === void 0) {
    store.set(id, value, timestamp);
    return value;
  }
  dt = timestamp - prev_timestamp;
  gamma = 1.0 / (dt / gamma0 + 1);
  new_value = gamma * prev_value + (1 - gamma) * value;
  store.set(id, new_value, timestamp);
  return new_value;
};

counter = function(key, id, gamma0, timestamp, reset) {
  var prev_timestamp, prev_value, store, value, _ref;

  key = key.toString();
  id = id.toString();
  store = getStore(key);
  _ref = store.get(id), prev_value = _ref[0], prev_timestamp = _ref[1];
  if (reset || !prev_timestamp) {
    value = void 0;
  } else {
    value = timestamp - prev_timestamp;
  }
  return gauge(key, id, value, gamma0, timestamp, reset);
};

getStore = function(key) {
  var store;

  store = stores[key];
  if (!store) {
    store = new lss.LimitedSizeStore();
    stores[key] = store;
  }
  return store;
};

initStores(argv['stores']);

startUDP(argv['udp-port'] || 1234);

startHTTP(argv['http-port'] || 1234);
